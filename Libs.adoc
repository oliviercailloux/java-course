= Libs

My recommendations concerning various libraries.

* Google https://github.com/google/guava[Guava]: “new collection types (such as multimap and multiset), immutable collections, a graph library, functional types, an in-memory cache, and APIs/utilities for concurrency, I/O, hashing, primitives, reflection, string processing, and much more”. You should definitely use their preconditions helpers. Then check whatever else you might have a use for.
* Parse https://en.wikipedia.org/wiki/Comma-separated_values[CSV] files: https://github.com/osiegmar/FastCSV[FastCSV] 2014 to 2024, very simple, 524 stars; https://github.com/apache/commons-csv[commons-csv] 2005 to 2024 and 374 stars; https://github.com/42BV/CSVeed[CSVeed] 2013 to 2024 and using beans and 99 stars; https://github.com/appendium/flatpack[flatpack] 2005 to 2024 and 57 stars; https://super-csv.github.io/super-csv/index.html[SuperCSV] is https://github.com/super-csv/super-csv[old]; https://github.com/uniVocity/univocity-parsers[uniVocity] is https://github.com/uniVocity/univocity-parsers/issues/534[abandoned]; more https://www.baeldung.com/java-csv#third-party-libraries[references]
* Parse command line arguments: I have used Apache http://commons.apache.org/proper/commons-cli/[Commons CLI], but I’d encourage you to check out https://jcommander.org/[JCommander], or https://java.libhunt.com/compare-jcommander-vs-jopt-simple[perhaps] http://jopt-simple.github.io/jopt-simple/[JOpt Simple].
* https://en.wikipedia.org/wiki/ICalendar[iCalendar] (ical, ics) files: according to https://stackoverflow.com/questions/33901/best-icalendar-library-for-java[SO], https://github.com/mangstadt/biweekly[biweekly] is better than https://github.com/ical4j/ical4j[iCal4j]. I found that iCal4j has very scarce http://ical4j.sourceforge.net/introduction.html[documentation]. A minor inconvenience of both is that they use old date-time java objects rather than the new https://docs.oracle.com/javase/tutorial/datetime/[java.time] API.
* XML parsing: see https://github.com/oliviercailloux/java-course/blob/main/DOM.adoc[DOM]
* Graphs: Guava (see above) has nice Graph structures, but few algorithms. 
** JGraphT provides https://jgrapht.org/javadoc/org/jgrapht/graph/guava/package-summary.html[adapters] to Guava and is very active. 
** JUNG https://github.com/google/guava/wiki/GraphsExplained#why-should-i-use-it-instead-of-something-else[inspired] the structures of Guava; its most recent version is version 2.1.1, released 7 September 2016; https://github.com/jrtom/jung/issues/236#issuecomment-530532746[“it's active, it's just proceeding very slowly”]; this https://github.com/jrtom/jung/issues/222[issue] discusses its link to Guava. 
** https://graphstream-project.org/[GraphStream] has a research team behind it, but I don’t like its core api: a node is a heavy interface that your own nodes have to extend. No apparent link to Guava.
** https://github.com/apache/commons-graph/[Apache commons graph] has gone https://markmail.org/search/?q=graph%20list%3Aorg.apache.commons.users%2F#query:graph%20list%3Aorg.apache.commons.users%2F+page:1+mid:mmbhrpnpqyspml3s+state:results[unmaintained] for a long time but was reactivated and committed to during https://github.com/apache/commons-graph/commits/master[June to Aug. 2020] then every few months from Oct 2022 (related discussions on the ML: https://www.mail-archive.com/dev@commons.apache.org/msg68827.html[still on sandbox ?], https://www.mail-archive.com/dev@commons.apache.org/msg68844.html[moving to git], https://www.mail-archive.com/dev@commons.apache.org/msg68914.html[Travis CI configuration], https://www.mail-archive.com/dev@commons.apache.org/msg68955.html[Build fails (unit tests)])
** Baeldung https://www.baeldung.com/java-graphs#4-sourceforge-jung[mentions] “more powerful frameworks based on graphs, such as Apache Giraph, currently used at Facebook to analyze the graph formed by their users, and Apache TinkerPop, commonly used on top of graph databases”, which I didn’t check.
** https://github.com/lhogie/grph[grph] is https://groups.google.com/d/msg/grph-high-performance-graphs-for-java/jHbFY5tVeTA/hIJofDLeCwAJ[not active] any more
** https://github.com/monora/jgraphl[jgraphl] is https://github.com/monora/jgraphl/commits/master[almost] inactive
* Personaly, I refrain from using https://github.com/vavr-io/vavr[vʌvr] (despite its very cool name), because it uses https://www.javadoc.io/static/io.vavr/vavr/0.10.3/io/vavr/control/Try.html#get--[sneaky throws] (this position is https://medium.com/@sebastien_pel/java-exception-and-lambda-to-go-sneaky-or-not-part-1-d31d6911eeed[debated]). Same for https://github.com/zalando/faux-pas#throwing-functional-interfaces[Faux Pas], https://noexception.machinezoo.com/javadoc/com/machinezoo/noexception/Exceptions.html#sneak--[NoException] and _fge_’s https://github.com/fge/throwing-lambdas/wiki/How-it-works#throwing-and-chainer[throwing-lambdas].
* Native system information: https://github.com/oshi/oshi[OSHI]
* JSON parsing: I like Jakarta. Although I like spec-driven APIs, I do not recommend JSON-B anymore. Here are the reasons.
** The spec process is painfully slow. In June 2021 discussions started about https://github.com/jakartaee/jsonb-api/issues/278[supporting records] officially; it was soon clear that implementations in fact did support them already, but more than three years later (Jan 2025), still nothing in the spec.
*** Jackson: similar https://github.com/FasterXML/jackson-databind/issues/3180[discussion] started in June 2021, issue completed in January 2023.
** The spec wording is often unclear, it seems to not have been reviewed by fluent English speakers.
** The discussions to improve the spec are painfully slow and non-converging. I have spent unreasonable efforts making a https://github.com/jakartaee/jsonb-api/issues/108[simple point] (`close()` throws `Exception`, it shouldn’t), to no avail; here are https://github.com/jakartaee/jsonb-api/issues/112[other] https://github.com/jakartaee/jsonb-api/issues/346[examples].
** There is a huge difference between the number of users of JSON-B and its main alternatives (GSON and Jackson), judging by the number of artifacts in Maven central using them. This lets me think that JSON-B will evolve slower than the alternatives, so that the gap will grow.
** More voices for Jackson VS JSON-B https://groups.google.com/g/quarkus-dev/c/RTnvH6LSdxs?pli=1[here].
