= Exceptions
//works around awesome_bot bug that used to be published at github.com/dkhamsing/awesome_bot/issues/182.
:emptyattribute:

== Catch exceptions only if you have a good reason to do so
Beginner programmers sometimes catch an exception just to get rid of the problem, and do not do anything in the catch block (or just log or print the exception). This is very bad style as it contradicts the fail-fast principle. Consider rather to re-throw the exception, or to wrap it in an unchecked exception (see point below).

== Change exception type if appropriate
You sometimes want to throw another type of exception than the type declared by the method you call. For example, someone has designed a method `serializeObject(SomeObject) throws StrangeException`, and you want, if the `serializeObject` method throws, to throw something more appropriate, such as your own `SerializationException`. Proceed as follows to https://stackoverflow.com/questions/28972893/what-is-exception-wrapping-in-java[wrap] `StrangeException` into `SerializationException`.

[source, Java]
----
try {
  serializeObject(myObject)
} catch (StrangeException e) {
  throw new SerializationException(e);
}
----

You may want to use this idiom to wrap `IOException` into `UncheckedIOException` instances.

== Do not log and throw
If you throw an exception, avoid logging the exception as well. This would lead to double logging, as the caller of the code would also possibly log upon receiving the exception. Only the part of the code that finally deals with the exception and does not re-throw it, if any, should decide of the appropriate action.

== Exception declaration
A method must declare all exceptions that it can possibly throw that do not extend `RuntimeException`. Runtime exceptions should generally not be declared. Declare those only if you see a specific reason to draw attention to it.

== Throw appropriate exceptions
=== Throw `IllegalStateException` when the state is incorrect
When your object, or the external environment, is in a state that does not permit to call the current method, throw `IllegalStateException`. Even if the problem is that some internal reference is `null`. For example, your `Database` class requires the `connection` field to be not `null` before calling `requestData()`. If the user breaks this requirement, the method `requestData()` should throw `IllegalStateException`, not `NullPointerException` (which, by convention, indicates that a received _argument_ is `null` and should not be). There is no incorrect argument here! Thus, you may not use `https://guava.dev/releases/snapshot/api/docs/com/google/common/base/Preconditions.html#checkNotNull-T-{emptyattribute}[checkNotNull](connection)` in that case.

=== Throw `IllegalArgumentException` when an argument is incorrect
When an argument received in your method is incorrect, throw `IllegalArgumentException` (except when the argument is `null`, see below). Even if the problem is that this incorrect argument yields a `null` reference in some internal call. For example, if you require an existing key as an argument, and you call `map.get(arg)` and this returns `null` because there is no key corresponding to `arg` in `map`, you should throw `IllegalArgumentException` and `NullPointerException`.

=== Throw `NullPointerException` when receiving an incorrect `null` argument
There’s some debate about whether `NullPointerException` or `IllegalArgumentException` should be thrown when receiving an incorrect `null` argument in a method. 

The argument in favor of the latter is that it is clear to the caller that a fault occurred because of an incorrect argument, rather than because of the designer of the API having by mistake tried to access some `null` value. I admit this is a good argument but there are also good arguments against. 

Thus, I consider it sensible to follow the standard. And the standard is to throw `NullPointerException`.

* Many APIs in the JDK pro-actively throws `NullPointerException`, e.g. https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Map.html#containsKey(java.lang.Object){emptyattribute}[`Map.containsKey`], https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Objects.html#requireNonNull(T){emptyattribute}[`Objects.requireNonNull`] (https://stackoverflow.com/questions/3881/illegalargumentexception-or-nullpointerexception-for-a-null-parameter/6358#6358[thanks]{emptyattribute}.)
* https://guava.dev/releases/snapshot/api/docs/com/google/common/base/Preconditions.html#checkNotNull-T-[Guava] also favors `NullPointerException` over `IllegalArgumentException`.
* “Effective Java” agrees, see https://stackoverflow.com/a/6358[SO].

=== Throw `VerifyException` when some internal verification fails
When your test is there to ensure that your internal logic is correct, if it fails, you should throw a `VerificationException`: this conveys clearly to the user that it is not her problem but yours. As an exemple, this happens if you compute an intermediate result which should be non-negative, and you realize it is in fact negative. Or if you call a method in a library that should return a non-null value, but it happens to be null. Use the Guava https://guava.dev/releases/snapshot/api/docs/com/google/common/base/Verify.html[`Verify`] class for this.

== Declare most general exceptions on non callable methods
Some methods are conceived to be executed, not to be called by other methods: `main` methods and unit testing methods. In such cases, the precise list of exceptions that can be thrown is irrelevant. Just declare that the method throws `Exception` and do not worry about it.

== Tests and main should throw `Exception`
In methods that are not designed to be called (such as unit testing and `main` methods), a detailed list of the kinds of exceptions that can be thrown is not very useful. Maintaining such a list is cumbersome, and an incorrect list is worst than no list. 

Thus, instead of `testWrite() throws NoSuchFileException, DatabaseException, ParsingException`, choose: `testWrite() throws Exception`, and do not worry about it.

